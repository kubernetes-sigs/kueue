// Code generated by MockGen. DO NOT EDIT.
// Source: pkg/controller/jobframework/interface.go
//
// Generated by this command:
//
//	mockgen -source=pkg/controller/jobframework/interface.go -destination=/Users/ichekrygin/src/sigs.k8s.io/kueue/internal/mocks/internal/mocks/controller/jobframework/interface.go -package mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	gomock "go.uber.org/mock/gomock"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	runtime "k8s.io/apimachinery/pkg/runtime"
	schema "k8s.io/apimachinery/pkg/runtime/schema"
	types "k8s.io/apimachinery/pkg/types"
	field "k8s.io/apimachinery/pkg/util/validation/field"
	record "k8s.io/client-go/tools/record"
	client "sigs.k8s.io/controller-runtime/pkg/client"
	v1beta1 "sigs.k8s.io/kueue/apis/kueue/v1beta1"
	jobframework "sigs.k8s.io/kueue/pkg/controller/jobframework"
	podset "sigs.k8s.io/kueue/pkg/podset"
)

// MockGenericJob is a mock of GenericJob interface.
type MockGenericJob struct {
	ctrl     *gomock.Controller
	recorder *MockGenericJobMockRecorder
	isgomock struct{}
}

// MockGenericJobMockRecorder is the mock recorder for MockGenericJob.
type MockGenericJobMockRecorder struct {
	mock *MockGenericJob
}

// NewMockGenericJob creates a new mock instance.
func NewMockGenericJob(ctrl *gomock.Controller) *MockGenericJob {
	mock := &MockGenericJob{ctrl: ctrl}
	mock.recorder = &MockGenericJobMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGenericJob) EXPECT() *MockGenericJobMockRecorder {
	return m.recorder
}

// Finished mocks base method.
func (m *MockGenericJob) Finished() (string, bool, bool) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Finished")
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(bool)
	ret2, _ := ret[2].(bool)
	return ret0, ret1, ret2
}

// Finished indicates an expected call of Finished.
func (mr *MockGenericJobMockRecorder) Finished() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Finished", reflect.TypeOf((*MockGenericJob)(nil).Finished))
}

// GVK mocks base method.
func (m *MockGenericJob) GVK() schema.GroupVersionKind {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GVK")
	ret0, _ := ret[0].(schema.GroupVersionKind)
	return ret0
}

// GVK indicates an expected call of GVK.
func (mr *MockGenericJobMockRecorder) GVK() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GVK", reflect.TypeOf((*MockGenericJob)(nil).GVK))
}

// IsActive mocks base method.
func (m *MockGenericJob) IsActive() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsActive")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsActive indicates an expected call of IsActive.
func (mr *MockGenericJobMockRecorder) IsActive() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsActive", reflect.TypeOf((*MockGenericJob)(nil).IsActive))
}

// IsSuspended mocks base method.
func (m *MockGenericJob) IsSuspended() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsSuspended")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsSuspended indicates an expected call of IsSuspended.
func (mr *MockGenericJobMockRecorder) IsSuspended() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsSuspended", reflect.TypeOf((*MockGenericJob)(nil).IsSuspended))
}

// Object mocks base method.
func (m *MockGenericJob) Object() client.Object {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Object")
	ret0, _ := ret[0].(client.Object)
	return ret0
}

// Object indicates an expected call of Object.
func (mr *MockGenericJobMockRecorder) Object() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Object", reflect.TypeOf((*MockGenericJob)(nil).Object))
}

// PodSets mocks base method.
func (m *MockGenericJob) PodSets() ([]v1beta1.PodSet, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PodSets")
	ret0, _ := ret[0].([]v1beta1.PodSet)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PodSets indicates an expected call of PodSets.
func (mr *MockGenericJobMockRecorder) PodSets() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PodSets", reflect.TypeOf((*MockGenericJob)(nil).PodSets))
}

// PodsReady mocks base method.
func (m *MockGenericJob) PodsReady() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PodsReady")
	ret0, _ := ret[0].(bool)
	return ret0
}

// PodsReady indicates an expected call of PodsReady.
func (mr *MockGenericJobMockRecorder) PodsReady() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PodsReady", reflect.TypeOf((*MockGenericJob)(nil).PodsReady))
}

// RestorePodSetsInfo mocks base method.
func (m *MockGenericJob) RestorePodSetsInfo(podSetsInfo []podset.PodSetInfo) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RestorePodSetsInfo", podSetsInfo)
	ret0, _ := ret[0].(bool)
	return ret0
}

// RestorePodSetsInfo indicates an expected call of RestorePodSetsInfo.
func (mr *MockGenericJobMockRecorder) RestorePodSetsInfo(podSetsInfo any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RestorePodSetsInfo", reflect.TypeOf((*MockGenericJob)(nil).RestorePodSetsInfo), podSetsInfo)
}

// RunWithPodSetsInfo mocks base method.
func (m *MockGenericJob) RunWithPodSetsInfo(podSetsInfo []podset.PodSetInfo) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RunWithPodSetsInfo", podSetsInfo)
	ret0, _ := ret[0].(error)
	return ret0
}

// RunWithPodSetsInfo indicates an expected call of RunWithPodSetsInfo.
func (mr *MockGenericJobMockRecorder) RunWithPodSetsInfo(podSetsInfo any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RunWithPodSetsInfo", reflect.TypeOf((*MockGenericJob)(nil).RunWithPodSetsInfo), podSetsInfo)
}

// Suspend mocks base method.
func (m *MockGenericJob) Suspend() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Suspend")
}

// Suspend indicates an expected call of Suspend.
func (mr *MockGenericJobMockRecorder) Suspend() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Suspend", reflect.TypeOf((*MockGenericJob)(nil).Suspend))
}

// MockJobWithPodLabelSelector is a mock of JobWithPodLabelSelector interface.
type MockJobWithPodLabelSelector struct {
	ctrl     *gomock.Controller
	recorder *MockJobWithPodLabelSelectorMockRecorder
	isgomock struct{}
}

// MockJobWithPodLabelSelectorMockRecorder is the mock recorder for MockJobWithPodLabelSelector.
type MockJobWithPodLabelSelectorMockRecorder struct {
	mock *MockJobWithPodLabelSelector
}

// NewMockJobWithPodLabelSelector creates a new mock instance.
func NewMockJobWithPodLabelSelector(ctrl *gomock.Controller) *MockJobWithPodLabelSelector {
	mock := &MockJobWithPodLabelSelector{ctrl: ctrl}
	mock.recorder = &MockJobWithPodLabelSelectorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockJobWithPodLabelSelector) EXPECT() *MockJobWithPodLabelSelectorMockRecorder {
	return m.recorder
}

// PodLabelSelector mocks base method.
func (m *MockJobWithPodLabelSelector) PodLabelSelector() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PodLabelSelector")
	ret0, _ := ret[0].(string)
	return ret0
}

// PodLabelSelector indicates an expected call of PodLabelSelector.
func (mr *MockJobWithPodLabelSelectorMockRecorder) PodLabelSelector() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PodLabelSelector", reflect.TypeOf((*MockJobWithPodLabelSelector)(nil).PodLabelSelector))
}

// MockJobWithReclaimablePods is a mock of JobWithReclaimablePods interface.
type MockJobWithReclaimablePods struct {
	ctrl     *gomock.Controller
	recorder *MockJobWithReclaimablePodsMockRecorder
	isgomock struct{}
}

// MockJobWithReclaimablePodsMockRecorder is the mock recorder for MockJobWithReclaimablePods.
type MockJobWithReclaimablePodsMockRecorder struct {
	mock *MockJobWithReclaimablePods
}

// NewMockJobWithReclaimablePods creates a new mock instance.
func NewMockJobWithReclaimablePods(ctrl *gomock.Controller) *MockJobWithReclaimablePods {
	mock := &MockJobWithReclaimablePods{ctrl: ctrl}
	mock.recorder = &MockJobWithReclaimablePodsMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockJobWithReclaimablePods) EXPECT() *MockJobWithReclaimablePodsMockRecorder {
	return m.recorder
}

// ReclaimablePods mocks base method.
func (m *MockJobWithReclaimablePods) ReclaimablePods() ([]v1beta1.ReclaimablePod, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReclaimablePods")
	ret0, _ := ret[0].([]v1beta1.ReclaimablePod)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReclaimablePods indicates an expected call of ReclaimablePods.
func (mr *MockJobWithReclaimablePodsMockRecorder) ReclaimablePods() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReclaimablePods", reflect.TypeOf((*MockJobWithReclaimablePods)(nil).ReclaimablePods))
}

// MockJobWithCustomStop is a mock of JobWithCustomStop interface.
type MockJobWithCustomStop struct {
	ctrl     *gomock.Controller
	recorder *MockJobWithCustomStopMockRecorder
	isgomock struct{}
}

// MockJobWithCustomStopMockRecorder is the mock recorder for MockJobWithCustomStop.
type MockJobWithCustomStopMockRecorder struct {
	mock *MockJobWithCustomStop
}

// NewMockJobWithCustomStop creates a new mock instance.
func NewMockJobWithCustomStop(ctrl *gomock.Controller) *MockJobWithCustomStop {
	mock := &MockJobWithCustomStop{ctrl: ctrl}
	mock.recorder = &MockJobWithCustomStopMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockJobWithCustomStop) EXPECT() *MockJobWithCustomStopMockRecorder {
	return m.recorder
}

// Stop mocks base method.
func (m *MockJobWithCustomStop) Stop(ctx context.Context, c client.Client, podSetsInfo []podset.PodSetInfo, stopReason jobframework.StopReason, eventMsg string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Stop", ctx, c, podSetsInfo, stopReason, eventMsg)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Stop indicates an expected call of Stop.
func (mr *MockJobWithCustomStopMockRecorder) Stop(ctx, c, podSetsInfo, stopReason, eventMsg any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stop", reflect.TypeOf((*MockJobWithCustomStop)(nil).Stop), ctx, c, podSetsInfo, stopReason, eventMsg)
}

// MockJobWithFinalize is a mock of JobWithFinalize interface.
type MockJobWithFinalize struct {
	ctrl     *gomock.Controller
	recorder *MockJobWithFinalizeMockRecorder
	isgomock struct{}
}

// MockJobWithFinalizeMockRecorder is the mock recorder for MockJobWithFinalize.
type MockJobWithFinalizeMockRecorder struct {
	mock *MockJobWithFinalize
}

// NewMockJobWithFinalize creates a new mock instance.
func NewMockJobWithFinalize(ctrl *gomock.Controller) *MockJobWithFinalize {
	mock := &MockJobWithFinalize{ctrl: ctrl}
	mock.recorder = &MockJobWithFinalizeMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockJobWithFinalize) EXPECT() *MockJobWithFinalizeMockRecorder {
	return m.recorder
}

// Finalize mocks base method.
func (m *MockJobWithFinalize) Finalize(ctx context.Context, c client.Client) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Finalize", ctx, c)
	ret0, _ := ret[0].(error)
	return ret0
}

// Finalize indicates an expected call of Finalize.
func (mr *MockJobWithFinalizeMockRecorder) Finalize(ctx, c any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Finalize", reflect.TypeOf((*MockJobWithFinalize)(nil).Finalize), ctx, c)
}

// MockJobWithSkip is a mock of JobWithSkip interface.
type MockJobWithSkip struct {
	ctrl     *gomock.Controller
	recorder *MockJobWithSkipMockRecorder
	isgomock struct{}
}

// MockJobWithSkipMockRecorder is the mock recorder for MockJobWithSkip.
type MockJobWithSkipMockRecorder struct {
	mock *MockJobWithSkip
}

// NewMockJobWithSkip creates a new mock instance.
func NewMockJobWithSkip(ctrl *gomock.Controller) *MockJobWithSkip {
	mock := &MockJobWithSkip{ctrl: ctrl}
	mock.recorder = &MockJobWithSkipMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockJobWithSkip) EXPECT() *MockJobWithSkipMockRecorder {
	return m.recorder
}

// Skip mocks base method.
func (m *MockJobWithSkip) Skip() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Skip")
	ret0, _ := ret[0].(bool)
	return ret0
}

// Skip indicates an expected call of Skip.
func (mr *MockJobWithSkipMockRecorder) Skip() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Skip", reflect.TypeOf((*MockJobWithSkip)(nil).Skip))
}

// MockJobWithPriorityClass is a mock of JobWithPriorityClass interface.
type MockJobWithPriorityClass struct {
	ctrl     *gomock.Controller
	recorder *MockJobWithPriorityClassMockRecorder
	isgomock struct{}
}

// MockJobWithPriorityClassMockRecorder is the mock recorder for MockJobWithPriorityClass.
type MockJobWithPriorityClassMockRecorder struct {
	mock *MockJobWithPriorityClass
}

// NewMockJobWithPriorityClass creates a new mock instance.
func NewMockJobWithPriorityClass(ctrl *gomock.Controller) *MockJobWithPriorityClass {
	mock := &MockJobWithPriorityClass{ctrl: ctrl}
	mock.recorder = &MockJobWithPriorityClassMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockJobWithPriorityClass) EXPECT() *MockJobWithPriorityClassMockRecorder {
	return m.recorder
}

// PriorityClass mocks base method.
func (m *MockJobWithPriorityClass) PriorityClass() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PriorityClass")
	ret0, _ := ret[0].(string)
	return ret0
}

// PriorityClass indicates an expected call of PriorityClass.
func (mr *MockJobWithPriorityClassMockRecorder) PriorityClass() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PriorityClass", reflect.TypeOf((*MockJobWithPriorityClass)(nil).PriorityClass))
}

// MockJobWithCustomValidation is a mock of JobWithCustomValidation interface.
type MockJobWithCustomValidation struct {
	ctrl     *gomock.Controller
	recorder *MockJobWithCustomValidationMockRecorder
	isgomock struct{}
}

// MockJobWithCustomValidationMockRecorder is the mock recorder for MockJobWithCustomValidation.
type MockJobWithCustomValidationMockRecorder struct {
	mock *MockJobWithCustomValidation
}

// NewMockJobWithCustomValidation creates a new mock instance.
func NewMockJobWithCustomValidation(ctrl *gomock.Controller) *MockJobWithCustomValidation {
	mock := &MockJobWithCustomValidation{ctrl: ctrl}
	mock.recorder = &MockJobWithCustomValidationMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockJobWithCustomValidation) EXPECT() *MockJobWithCustomValidationMockRecorder {
	return m.recorder
}

// ValidateOnCreate mocks base method.
func (m *MockJobWithCustomValidation) ValidateOnCreate() (field.ErrorList, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ValidateOnCreate")
	ret0, _ := ret[0].(field.ErrorList)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ValidateOnCreate indicates an expected call of ValidateOnCreate.
func (mr *MockJobWithCustomValidationMockRecorder) ValidateOnCreate() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ValidateOnCreate", reflect.TypeOf((*MockJobWithCustomValidation)(nil).ValidateOnCreate))
}

// ValidateOnUpdate mocks base method.
func (m *MockJobWithCustomValidation) ValidateOnUpdate(oldJob jobframework.GenericJob) (field.ErrorList, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ValidateOnUpdate", oldJob)
	ret0, _ := ret[0].(field.ErrorList)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ValidateOnUpdate indicates an expected call of ValidateOnUpdate.
func (mr *MockJobWithCustomValidationMockRecorder) ValidateOnUpdate(oldJob any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ValidateOnUpdate", reflect.TypeOf((*MockJobWithCustomValidation)(nil).ValidateOnUpdate), oldJob)
}

// MockComposableJob is a mock of ComposableJob interface.
type MockComposableJob struct {
	ctrl     *gomock.Controller
	recorder *MockComposableJobMockRecorder
	isgomock struct{}
}

// MockComposableJobMockRecorder is the mock recorder for MockComposableJob.
type MockComposableJobMockRecorder struct {
	mock *MockComposableJob
}

// NewMockComposableJob creates a new mock instance.
func NewMockComposableJob(ctrl *gomock.Controller) *MockComposableJob {
	mock := &MockComposableJob{ctrl: ctrl}
	mock.recorder = &MockComposableJobMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockComposableJob) EXPECT() *MockComposableJobMockRecorder {
	return m.recorder
}

// ConstructComposableWorkload mocks base method.
func (m *MockComposableJob) ConstructComposableWorkload(ctx context.Context, c client.Client, r record.EventRecorder, labelKeysToCopy []string) (*v1beta1.Workload, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ConstructComposableWorkload", ctx, c, r, labelKeysToCopy)
	ret0, _ := ret[0].(*v1beta1.Workload)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ConstructComposableWorkload indicates an expected call of ConstructComposableWorkload.
func (mr *MockComposableJobMockRecorder) ConstructComposableWorkload(ctx, c, r, labelKeysToCopy any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConstructComposableWorkload", reflect.TypeOf((*MockComposableJob)(nil).ConstructComposableWorkload), ctx, c, r, labelKeysToCopy)
}

// EnsureWorkloadOwnedByAllMembers mocks base method.
func (m *MockComposableJob) EnsureWorkloadOwnedByAllMembers(ctx context.Context, c client.Client, r record.EventRecorder, workload *v1beta1.Workload) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "EnsureWorkloadOwnedByAllMembers", ctx, c, r, workload)
	ret0, _ := ret[0].(error)
	return ret0
}

// EnsureWorkloadOwnedByAllMembers indicates an expected call of EnsureWorkloadOwnedByAllMembers.
func (mr *MockComposableJobMockRecorder) EnsureWorkloadOwnedByAllMembers(ctx, c, r, workload any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EnsureWorkloadOwnedByAllMembers", reflect.TypeOf((*MockComposableJob)(nil).EnsureWorkloadOwnedByAllMembers), ctx, c, r, workload)
}

// EquivalentToWorkload mocks base method.
func (m *MockComposableJob) EquivalentToWorkload(ctx context.Context, c client.Client, wl *v1beta1.Workload) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "EquivalentToWorkload", ctx, c, wl)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// EquivalentToWorkload indicates an expected call of EquivalentToWorkload.
func (mr *MockComposableJobMockRecorder) EquivalentToWorkload(ctx, c, wl any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EquivalentToWorkload", reflect.TypeOf((*MockComposableJob)(nil).EquivalentToWorkload), ctx, c, wl)
}

// FindMatchingWorkloads mocks base method.
func (m *MockComposableJob) FindMatchingWorkloads(ctx context.Context, c client.Client, r record.EventRecorder) (*v1beta1.Workload, []*v1beta1.Workload, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindMatchingWorkloads", ctx, c, r)
	ret0, _ := ret[0].(*v1beta1.Workload)
	ret1, _ := ret[1].([]*v1beta1.Workload)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// FindMatchingWorkloads indicates an expected call of FindMatchingWorkloads.
func (mr *MockComposableJobMockRecorder) FindMatchingWorkloads(ctx, c, r any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindMatchingWorkloads", reflect.TypeOf((*MockComposableJob)(nil).FindMatchingWorkloads), ctx, c, r)
}

// ForEach mocks base method.
func (m *MockComposableJob) ForEach(f func(runtime.Object)) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ForEach", f)
}

// ForEach indicates an expected call of ForEach.
func (mr *MockComposableJobMockRecorder) ForEach(f any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ForEach", reflect.TypeOf((*MockComposableJob)(nil).ForEach), f)
}

// ListChildWorkloads mocks base method.
func (m *MockComposableJob) ListChildWorkloads(ctx context.Context, c client.Client, parent types.NamespacedName) (*v1beta1.WorkloadList, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListChildWorkloads", ctx, c, parent)
	ret0, _ := ret[0].(*v1beta1.WorkloadList)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListChildWorkloads indicates an expected call of ListChildWorkloads.
func (mr *MockComposableJobMockRecorder) ListChildWorkloads(ctx, c, parent any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListChildWorkloads", reflect.TypeOf((*MockComposableJob)(nil).ListChildWorkloads), ctx, c, parent)
}

// Load mocks base method.
func (m *MockComposableJob) Load(ctx context.Context, c client.Client, key *types.NamespacedName) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Load", ctx, c, key)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Load indicates an expected call of Load.
func (mr *MockComposableJobMockRecorder) Load(ctx, c, key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Load", reflect.TypeOf((*MockComposableJob)(nil).Load), ctx, c, key)
}

// Run mocks base method.
func (m *MockComposableJob) Run(ctx context.Context, c client.Client, podSetsInfo []podset.PodSetInfo, r record.EventRecorder, msg string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Run", ctx, c, podSetsInfo, r, msg)
	ret0, _ := ret[0].(error)
	return ret0
}

// Run indicates an expected call of Run.
func (mr *MockComposableJobMockRecorder) Run(ctx, c, podSetsInfo, r, msg any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Run", reflect.TypeOf((*MockComposableJob)(nil).Run), ctx, c, podSetsInfo, r, msg)
}

// Stop mocks base method.
func (m *MockComposableJob) Stop(ctx context.Context, c client.Client, podSetsInfo []podset.PodSetInfo, stopReason jobframework.StopReason, eventMsg string) ([]client.Object, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Stop", ctx, c, podSetsInfo, stopReason, eventMsg)
	ret0, _ := ret[0].([]client.Object)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Stop indicates an expected call of Stop.
func (mr *MockComposableJobMockRecorder) Stop(ctx, c, podSetsInfo, stopReason, eventMsg any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stop", reflect.TypeOf((*MockComposableJob)(nil).Stop), ctx, c, podSetsInfo, stopReason, eventMsg)
}

// MockJobWithCustomWorkloadConditions is a mock of JobWithCustomWorkloadConditions interface.
type MockJobWithCustomWorkloadConditions struct {
	ctrl     *gomock.Controller
	recorder *MockJobWithCustomWorkloadConditionsMockRecorder
	isgomock struct{}
}

// MockJobWithCustomWorkloadConditionsMockRecorder is the mock recorder for MockJobWithCustomWorkloadConditions.
type MockJobWithCustomWorkloadConditionsMockRecorder struct {
	mock *MockJobWithCustomWorkloadConditions
}

// NewMockJobWithCustomWorkloadConditions creates a new mock instance.
func NewMockJobWithCustomWorkloadConditions(ctrl *gomock.Controller) *MockJobWithCustomWorkloadConditions {
	mock := &MockJobWithCustomWorkloadConditions{ctrl: ctrl}
	mock.recorder = &MockJobWithCustomWorkloadConditionsMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockJobWithCustomWorkloadConditions) EXPECT() *MockJobWithCustomWorkloadConditionsMockRecorder {
	return m.recorder
}

// CustomWorkloadConditions mocks base method.
func (m *MockJobWithCustomWorkloadConditions) CustomWorkloadConditions(wl *v1beta1.Workload) ([]v1.Condition, bool) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CustomWorkloadConditions", wl)
	ret0, _ := ret[0].([]v1.Condition)
	ret1, _ := ret[1].(bool)
	return ret0, ret1
}

// CustomWorkloadConditions indicates an expected call of CustomWorkloadConditions.
func (mr *MockJobWithCustomWorkloadConditionsMockRecorder) CustomWorkloadConditions(wl any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CustomWorkloadConditions", reflect.TypeOf((*MockJobWithCustomWorkloadConditions)(nil).CustomWorkloadConditions), wl)
}

// MockJobWithManagedBy is a mock of JobWithManagedBy interface.
type MockJobWithManagedBy struct {
	ctrl     *gomock.Controller
	recorder *MockJobWithManagedByMockRecorder
	isgomock struct{}
}

// MockJobWithManagedByMockRecorder is the mock recorder for MockJobWithManagedBy.
type MockJobWithManagedByMockRecorder struct {
	mock *MockJobWithManagedBy
}

// NewMockJobWithManagedBy creates a new mock instance.
func NewMockJobWithManagedBy(ctrl *gomock.Controller) *MockJobWithManagedBy {
	mock := &MockJobWithManagedBy{ctrl: ctrl}
	mock.recorder = &MockJobWithManagedByMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockJobWithManagedBy) EXPECT() *MockJobWithManagedByMockRecorder {
	return m.recorder
}

// CanDefaultManagedBy mocks base method.
func (m *MockJobWithManagedBy) CanDefaultManagedBy() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CanDefaultManagedBy")
	ret0, _ := ret[0].(bool)
	return ret0
}

// CanDefaultManagedBy indicates an expected call of CanDefaultManagedBy.
func (mr *MockJobWithManagedByMockRecorder) CanDefaultManagedBy() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CanDefaultManagedBy", reflect.TypeOf((*MockJobWithManagedBy)(nil).CanDefaultManagedBy))
}

// ManagedBy mocks base method.
func (m *MockJobWithManagedBy) ManagedBy() *string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ManagedBy")
	ret0, _ := ret[0].(*string)
	return ret0
}

// ManagedBy indicates an expected call of ManagedBy.
func (mr *MockJobWithManagedByMockRecorder) ManagedBy() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ManagedBy", reflect.TypeOf((*MockJobWithManagedBy)(nil).ManagedBy))
}

// SetManagedBy mocks base method.
func (m *MockJobWithManagedBy) SetManagedBy(arg0 *string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetManagedBy", arg0)
}

// SetManagedBy indicates an expected call of SetManagedBy.
func (mr *MockJobWithManagedByMockRecorder) SetManagedBy(arg0 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetManagedBy", reflect.TypeOf((*MockJobWithManagedBy)(nil).SetManagedBy), arg0)
}

// MockTopLevelJob is a mock of TopLevelJob interface.
type MockTopLevelJob struct {
	ctrl     *gomock.Controller
	recorder *MockTopLevelJobMockRecorder
	isgomock struct{}
}

// MockTopLevelJobMockRecorder is the mock recorder for MockTopLevelJob.
type MockTopLevelJobMockRecorder struct {
	mock *MockTopLevelJob
}

// NewMockTopLevelJob creates a new mock instance.
func NewMockTopLevelJob(ctrl *gomock.Controller) *MockTopLevelJob {
	mock := &MockTopLevelJob{ctrl: ctrl}
	mock.recorder = &MockTopLevelJobMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTopLevelJob) EXPECT() *MockTopLevelJobMockRecorder {
	return m.recorder
}

// IsTopLevel mocks base method.
func (m *MockTopLevelJob) IsTopLevel() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsTopLevel")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsTopLevel indicates an expected call of IsTopLevel.
func (mr *MockTopLevelJobMockRecorder) IsTopLevel() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsTopLevel", reflect.TypeOf((*MockTopLevelJob)(nil).IsTopLevel))
}

// MockMultiKueueAdapter is a mock of MultiKueueAdapter interface.
type MockMultiKueueAdapter struct {
	ctrl     *gomock.Controller
	recorder *MockMultiKueueAdapterMockRecorder
	isgomock struct{}
}

// MockMultiKueueAdapterMockRecorder is the mock recorder for MockMultiKueueAdapter.
type MockMultiKueueAdapterMockRecorder struct {
	mock *MockMultiKueueAdapter
}

// NewMockMultiKueueAdapter creates a new mock instance.
func NewMockMultiKueueAdapter(ctrl *gomock.Controller) *MockMultiKueueAdapter {
	mock := &MockMultiKueueAdapter{ctrl: ctrl}
	mock.recorder = &MockMultiKueueAdapterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMultiKueueAdapter) EXPECT() *MockMultiKueueAdapterMockRecorder {
	return m.recorder
}

// DeleteRemoteObject mocks base method.
func (m *MockMultiKueueAdapter) DeleteRemoteObject(ctx context.Context, remoteClient client.Client, key types.NamespacedName) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteRemoteObject", ctx, remoteClient, key)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteRemoteObject indicates an expected call of DeleteRemoteObject.
func (mr *MockMultiKueueAdapterMockRecorder) DeleteRemoteObject(ctx, remoteClient, key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteRemoteObject", reflect.TypeOf((*MockMultiKueueAdapter)(nil).DeleteRemoteObject), ctx, remoteClient, key)
}

// GVK mocks base method.
func (m *MockMultiKueueAdapter) GVK() schema.GroupVersionKind {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GVK")
	ret0, _ := ret[0].(schema.GroupVersionKind)
	return ret0
}

// GVK indicates an expected call of GVK.
func (mr *MockMultiKueueAdapterMockRecorder) GVK() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GVK", reflect.TypeOf((*MockMultiKueueAdapter)(nil).GVK))
}

// IsJobManagedByKueue mocks base method.
func (m *MockMultiKueueAdapter) IsJobManagedByKueue(ctx context.Context, localClient client.Client, key types.NamespacedName) (bool, string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsJobManagedByKueue", ctx, localClient, key)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(string)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// IsJobManagedByKueue indicates an expected call of IsJobManagedByKueue.
func (mr *MockMultiKueueAdapterMockRecorder) IsJobManagedByKueue(ctx, localClient, key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsJobManagedByKueue", reflect.TypeOf((*MockMultiKueueAdapter)(nil).IsJobManagedByKueue), ctx, localClient, key)
}

// KeepAdmissionCheckPending mocks base method.
func (m *MockMultiKueueAdapter) KeepAdmissionCheckPending() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "KeepAdmissionCheckPending")
	ret0, _ := ret[0].(bool)
	return ret0
}

// KeepAdmissionCheckPending indicates an expected call of KeepAdmissionCheckPending.
func (mr *MockMultiKueueAdapterMockRecorder) KeepAdmissionCheckPending() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "KeepAdmissionCheckPending", reflect.TypeOf((*MockMultiKueueAdapter)(nil).KeepAdmissionCheckPending))
}

// SyncJob mocks base method.
func (m *MockMultiKueueAdapter) SyncJob(ctx context.Context, localClient, remoteClient client.Client, key types.NamespacedName, workloadName, origin string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SyncJob", ctx, localClient, remoteClient, key, workloadName, origin)
	ret0, _ := ret[0].(error)
	return ret0
}

// SyncJob indicates an expected call of SyncJob.
func (mr *MockMultiKueueAdapterMockRecorder) SyncJob(ctx, localClient, remoteClient, key, workloadName, origin any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SyncJob", reflect.TypeOf((*MockMultiKueueAdapter)(nil).SyncJob), ctx, localClient, remoteClient, key, workloadName, origin)
}

// MockMultiKueueWatcher is a mock of MultiKueueWatcher interface.
type MockMultiKueueWatcher struct {
	ctrl     *gomock.Controller
	recorder *MockMultiKueueWatcherMockRecorder
	isgomock struct{}
}

// MockMultiKueueWatcherMockRecorder is the mock recorder for MockMultiKueueWatcher.
type MockMultiKueueWatcherMockRecorder struct {
	mock *MockMultiKueueWatcher
}

// NewMockMultiKueueWatcher creates a new mock instance.
func NewMockMultiKueueWatcher(ctrl *gomock.Controller) *MockMultiKueueWatcher {
	mock := &MockMultiKueueWatcher{ctrl: ctrl}
	mock.recorder = &MockMultiKueueWatcherMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMultiKueueWatcher) EXPECT() *MockMultiKueueWatcherMockRecorder {
	return m.recorder
}

// GetEmptyList mocks base method.
func (m *MockMultiKueueWatcher) GetEmptyList() client.ObjectList {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetEmptyList")
	ret0, _ := ret[0].(client.ObjectList)
	return ret0
}

// GetEmptyList indicates an expected call of GetEmptyList.
func (mr *MockMultiKueueWatcherMockRecorder) GetEmptyList() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetEmptyList", reflect.TypeOf((*MockMultiKueueWatcher)(nil).GetEmptyList))
}

// WorkloadKeyFor mocks base method.
func (m *MockMultiKueueWatcher) WorkloadKeyFor(arg0 runtime.Object) (types.NamespacedName, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WorkloadKeyFor", arg0)
	ret0, _ := ret[0].(types.NamespacedName)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// WorkloadKeyFor indicates an expected call of WorkloadKeyFor.
func (mr *MockMultiKueueWatcherMockRecorder) WorkloadKeyFor(arg0 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WorkloadKeyFor", reflect.TypeOf((*MockMultiKueueWatcher)(nil).WorkloadKeyFor), arg0)
}
