/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by applyconfiguration-gen. DO NOT EDIT.

package v1beta2

import (
	v1 "k8s.io/client-go/applyconfigurations/meta/v1"
	kueuev1beta2 "sigs.k8s.io/kueue/apis/kueue/v1beta2"
)

// ClusterQueueSpecApplyConfiguration represents a declarative configuration of the ClusterQueueSpec type for use
// with apply.
//
// ClusterQueueSpec defines the desired state of ClusterQueue
type ClusterQueueSpecApplyConfiguration struct {
	// resourceGroups describes groups of resources.
	// Each resource group defines the list of resources and a list of flavors
	// that provide quotas for these resources.
	// Each resource and each flavor can only form part of one resource group.
	// resourceGroups can be up to 16, with a max of 256 total flavors across all groups.
	ResourceGroups []ResourceGroupApplyConfiguration `json:"resourceGroups,omitempty"`
	// cohortName that this ClusterQueue belongs to. CQs that belong to the
	// same cohort can borrow unused resources from each other.
	//
	// A CQ can be a member of a single borrowing cohort. A workload submitted
	// to a queue referencing this CQ can borrow quota from any CQ in the cohort.
	// Only quota for the [resource, flavor] pairs listed in the CQ can be
	// borrowed.
	// If empty, this ClusterQueue cannot borrow from any other ClusterQueue and
	// vice versa.
	//
	// A cohort is a name that links CQs together, but it doesn't reference any
	// object.
	CohortName *kueuev1beta2.CohortReference `json:"cohortName,omitempty"`
	// queueingStrategy indicates the queueing strategy of the workloads
	// across the queues in this ClusterQueue.
	// Current Supported Strategies:
	//
	// - StrictFIFO: workloads are ordered strictly by creation time.
	// Older workloads that can't be admitted will block admitting newer
	// workloads even if they fit available quota.
	// - BestEffortFIFO: workloads are ordered by creation time,
	// however older workloads that can't be admitted will not block
	// admitting newer workloads that fit existing quota.
	QueueingStrategy *kueuev1beta2.QueueingStrategy `json:"queueingStrategy,omitempty"`
	// namespaceSelector defines which namespaces are allowed to submit workloads to
	// this clusterQueue. Beyond this basic support for policy, a policy agent like
	// Gatekeeper should be used to enforce more advanced policies.
	// Defaults to null which is a nothing selector (no namespaces eligible).
	// If set to an empty selector `{}`, then all namespaces are eligible.
	NamespaceSelector *v1.LabelSelectorApplyConfiguration `json:"namespaceSelector,omitempty"`
	// flavorFungibility defines whether a workload should try the next flavor
	// before borrowing or preempting in the flavor being evaluated.
	FlavorFungibility *FlavorFungibilityApplyConfiguration `json:"flavorFungibility,omitempty"`
	// preemption defines the preemption policies.
	Preemption *ClusterQueuePreemptionApplyConfiguration `json:"preemption,omitempty"`
	// admissionChecksStrategy defines a list of strategies to determine which ResourceFlavors require AdmissionChecks.
	AdmissionChecksStrategy *AdmissionChecksStrategyApplyConfiguration `json:"admissionChecksStrategy,omitempty"`
	// stopPolicy - if set to a value different from None, the ClusterQueue is considered Inactive, no new reservation being
	// made.
	//
	// Depending on its value, its associated workloads will:
	//
	// - None - Workloads are admitted
	// - HoldAndDrain - Admitted workloads are evicted and Reserving workloads will cancel the reservation.
	// - Hold - Admitted workloads will run to completion and Reserving workloads will cancel the reservation.
	StopPolicy *kueuev1beta2.StopPolicy `json:"stopPolicy,omitempty"`
	// fairSharing defines the properties of the ClusterQueue when
	// participating in FairSharing.  The values are only relevant
	// if FairSharing is enabled in the Kueue configuration.
	FairSharing *FairSharingApplyConfiguration `json:"fairSharing,omitempty"`
	// admissionScope indicates whether ClusterQueue uses the Admission Fair Sharing
	AdmissionScope *AdmissionScopeApplyConfiguration `json:"admissionScope,omitempty"`
}

// ClusterQueueSpecApplyConfiguration constructs a declarative configuration of the ClusterQueueSpec type for use with
// apply.
func ClusterQueueSpec() *ClusterQueueSpecApplyConfiguration {
	return &ClusterQueueSpecApplyConfiguration{}
}

// WithResourceGroups adds the given value to the ResourceGroups field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the ResourceGroups field.
func (b *ClusterQueueSpecApplyConfiguration) WithResourceGroups(values ...*ResourceGroupApplyConfiguration) *ClusterQueueSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithResourceGroups")
		}
		b.ResourceGroups = append(b.ResourceGroups, *values[i])
	}
	return b
}

// WithCohortName sets the CohortName field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the CohortName field is set to the value of the last call.
func (b *ClusterQueueSpecApplyConfiguration) WithCohortName(value kueuev1beta2.CohortReference) *ClusterQueueSpecApplyConfiguration {
	b.CohortName = &value
	return b
}

// WithQueueingStrategy sets the QueueingStrategy field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the QueueingStrategy field is set to the value of the last call.
func (b *ClusterQueueSpecApplyConfiguration) WithQueueingStrategy(value kueuev1beta2.QueueingStrategy) *ClusterQueueSpecApplyConfiguration {
	b.QueueingStrategy = &value
	return b
}

// WithNamespaceSelector sets the NamespaceSelector field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the NamespaceSelector field is set to the value of the last call.
func (b *ClusterQueueSpecApplyConfiguration) WithNamespaceSelector(value *v1.LabelSelectorApplyConfiguration) *ClusterQueueSpecApplyConfiguration {
	b.NamespaceSelector = value
	return b
}

// WithFlavorFungibility sets the FlavorFungibility field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the FlavorFungibility field is set to the value of the last call.
func (b *ClusterQueueSpecApplyConfiguration) WithFlavorFungibility(value *FlavorFungibilityApplyConfiguration) *ClusterQueueSpecApplyConfiguration {
	b.FlavorFungibility = value
	return b
}

// WithPreemption sets the Preemption field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Preemption field is set to the value of the last call.
func (b *ClusterQueueSpecApplyConfiguration) WithPreemption(value *ClusterQueuePreemptionApplyConfiguration) *ClusterQueueSpecApplyConfiguration {
	b.Preemption = value
	return b
}

// WithAdmissionChecksStrategy sets the AdmissionChecksStrategy field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the AdmissionChecksStrategy field is set to the value of the last call.
func (b *ClusterQueueSpecApplyConfiguration) WithAdmissionChecksStrategy(value *AdmissionChecksStrategyApplyConfiguration) *ClusterQueueSpecApplyConfiguration {
	b.AdmissionChecksStrategy = value
	return b
}

// WithStopPolicy sets the StopPolicy field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the StopPolicy field is set to the value of the last call.
func (b *ClusterQueueSpecApplyConfiguration) WithStopPolicy(value kueuev1beta2.StopPolicy) *ClusterQueueSpecApplyConfiguration {
	b.StopPolicy = &value
	return b
}

// WithFairSharing sets the FairSharing field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the FairSharing field is set to the value of the last call.
func (b *ClusterQueueSpecApplyConfiguration) WithFairSharing(value *FairSharingApplyConfiguration) *ClusterQueueSpecApplyConfiguration {
	b.FairSharing = value
	return b
}

// WithAdmissionScope sets the AdmissionScope field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the AdmissionScope field is set to the value of the last call.
func (b *ClusterQueueSpecApplyConfiguration) WithAdmissionScope(value *AdmissionScopeApplyConfiguration) *ClusterQueueSpecApplyConfiguration {
	b.AdmissionScope = value
	return b
}
